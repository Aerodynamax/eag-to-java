"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const Long = require("long");
/**
 * An internal helper class to help deserialize and serialize from and to a `Buffer`.
 *
 * @hidden
 */
class BufferStream {
    constructor(buffer, debug = false) {
        this._index = 0;
        this.debug = false;
        this.buf = buffer;
        this.debug = debug;
    }
    get index() {
        return this._index;
    }
    getByte() {
        const out = this.buf.readInt8(this.index);
        this._index++;
        return out;
    }
    getDouble() {
        const out = this.buf.readDoubleBE(this.index);
        this._index += 8;
        return out;
    }
    getFloat() {
        const out = this.buf.readFloatBE(this.index);
        this._index += 4;
        return out;
    }
    getInt() {
        const out = this.buf.readInt32BE(this.index);
        this._index += 4;
        return out;
    }
    getLong() {
        const arr = this.buf.subarray(this.index, this.index + 8);
        this._index += 8;
        return Long.fromBytesBE([...arr]);
    }
    getShort() {
        const out = this.buf.readInt16BE(this.index);
        this._index += 2;
        return out;
    }
    getUTF8() {
        const len = this.getShort();
        const out = this.buf.toString("utf8", this.index, this.index + len);
        this._index += len;
        return out;
    }
    setByte(value) {
        if (this.debug) {
            assert_1.equal(this.getByte(), value);
            this._index--;
        }
        this.expand_by(1);
        this.buf.writeInt8(value, this.index);
        this._index++;
    }
    setDouble(value) {
        if (this.debug) {
            assert_1.equal(this.getDouble(), value);
            this._index -= 8;
        }
        this.expand_by(8);
        this.buf.writeDoubleBE(value, this.index);
        this._index += 8;
    }
    setFloat(value) {
        if (this.debug) {
            assert_1.equal(this.getFloat(), value);
            this._index -= 4;
        }
        this.expand_by(4);
        this.buf.writeFloatBE(value, this.index);
        this._index += 4;
    }
    setInt(value) {
        if (this.debug) {
            assert_1.equal(this.getInt(), value);
            this._index -= 4;
        }
        this.expand_by(4);
        this.buf.writeInt32BE(value, this.index);
        this._index += 4;
    }
    setLong(value) {
        if (this.debug) {
            assert_1.ok(this.getLong().equals(value));
            this._index -= 8;
        }
        this.expand_by(8);
        for (const byte of value.toBytesBE()) {
            // TODO: Verify
            this.buf.writeUInt8(byte, this.index);
            this._index++;
        }
    }
    setShort(value) {
        if (this.debug) {
            assert_1.equal(this.getShort(), value);
            this._index -= 2;
        }
        this.expand_by(2);
        this.buf.writeInt16BE(value, this.index);
        this._index += 2;
    }
    setUTF8(value) {
        const startindex = this.index;
        if (this.debug) {
            assert_1.equal(this.getUTF8(), value);
            this._index = startindex;
        }
        const len = Buffer.byteLength(value, "utf8");
        this.expand_by(len + 1);
        this.setShort(len);
        this.buf.write(value, this.index, undefined, "utf8");
        this._index += len;
    }
    getData() {
        if (this.debug) {
            assert_1.equal(this.buf.length, this.index);
        }
        return this.buf.slice(0, this.index);
    }
    expand_by(amount) {
        // We write to `this.index` first, so this should be a strictly >
        if (this.index + amount > this.buf.length) {
            this.buf = Buffer.alloc(this.buf.length * 2, this.buf);
        }
    }
}
exports.BufferStream = BufferStream;
