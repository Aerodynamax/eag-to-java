"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const zlib = require("zlib");
const buffer_stream_1 = require("./buffer-stream");
const tags_1 = require("./tags");
const unzipAsync = util_1.promisify(zlib.unzip);
/**
 * Deserialize an NBT value from `buffer`. This returns an object which is
 * the closest JavaScript equivalent of the input.
 * `TAG_LONG`s, which cannot be losslessly represented in a JavaScript
 * `number`, are deserialized as `Long`s from the
 * [`long`](https://www.npmjs.com/package/long) package.
 *
 * Deserialize an NBT value from `buffer`. This returns an object which is the closest JavaScript equivalent of the input.
 * `TAG_LONG`s, which cannot be losslessly represented in a JavaScript `number`, are deserialized as `Long`s from the [`long`](https://www.npmjs.com/package/long) package.
 *
 * The resulting object can be serialized into the same NBT value. This is explained fully in the `README`.
 *
 * @param buffer The buffer to deserialize the NBT from
 * @param useMaps Whether to use ES6 `Map`s for compounds. This is useful to retain insertion order
 * @param named Whether or not the root is named. For example, a typical structure is {"":<data>}. (Reasoning for this required)
 *
 * @throws If the NBT is malformed. E.g. an invalid tag type is specified or the NBT is truncated.
 */
function deserializeNBT(buffer, useMaps = false, named = true) {
    const stream = new buffer_stream_1.BufferStream(buffer);
    const id = stream.getByte();
    const name = named ? stream.getUTF8() : undefined;
    const result = deserializeTag(id, stream, useMaps);
    if (name) {
        Object.assign(result, { [tags_1.NBTNameSymbol]: name });
    }
    return result;
}
exports.deserializeNBT = deserializeNBT;
/**
 * Same as `deserializeNBT`, but if `buffer` contains compressed data, it will be uncompressed automatically. If this behaviour is not required, use the synchronous `deserializeNBT` function instead.
 *
 * @param buffer The buffer to deserialize the NBT from.
 * @param useMaps to use ES6 maps for compounds. This is useful to retain insertion order
 * @param named Whether or not the root is named. For example, a typical structure is {"":<data>}.
 *
 * @throws If the NBT is malformed. E.g. an invalid tag type is specified or the NBT is truncated.
 * @throws If the compression is invalid
 */
async function deserializeCompressedNBT(buffer, useMaps = false, named = true) {
    return deserializeNBT(await decompressIfNeeded(buffer), useMaps, named);
}
exports.deserializeCompressedNBT = deserializeCompressedNBT;
/**
 * Decompress a `Buffer` if required, returning the original Buffer otherwise
 *
 * @hidden Only exposed for tests
 */
async function decompressIfNeeded(buffer) {
    try {
        return await unzipAsync(buffer);
    }
    catch (e) {
        return buffer;
    }
}
exports.decompressIfNeeded = decompressIfNeeded;
function deserializeTag(type, buffer, useMaps) {
    switch (type) {
        case tags_1.TagType.TAG_BYTE:
            return tags_1.byte(Number(buffer.getByte()));
        case tags_1.TagType.TAG_SHORT:
            return tags_1.short(Number(buffer.getShort()));
        case tags_1.TagType.TAG_INT:
            return tags_1.int(Number(buffer.getInt()));
        case tags_1.TagType.TAG_LONG:
            return tags_1.long(buffer.getLong());
        case tags_1.TagType.TAG_FLOAT:
            return tags_1.float(Number(buffer.getFloat()));
        case tags_1.TagType.TAG_DOUBLE:
            return tags_1.double(Number(buffer.getDouble()));
        case tags_1.TagType.TAG_BYTE_ARRAY:
            const byteLen = buffer.getInt();
            const byteResult = tags_1.byteArray([]);
            for (let _i = 0; _i < byteLen; _i++) {
                byteResult.push(deserializeTag(tags_1.TagType.TAG_BYTE, buffer, useMaps));
            }
            return byteResult;
        case tags_1.TagType.TAG_STRING:
            return tags_1.string(buffer.getUTF8());
        case tags_1.TagType.TAG_LIST:
            const id = buffer.getByte();
            const listLen = buffer.getInt();
            const listResult = tags_1.list([]);
            Object.assign(listResult, { [tags_1.NBTListSymbol]: id });
            for (let _i = 0; _i < listLen; _i++) {
                listResult.push(deserializeTag(id, buffer, useMaps));
            }
            return listResult;
        case tags_1.TagType.TAG_COMPOUND:
            let kind = buffer.getByte();
            const result = tags_1.compound(new Map());
            while (kind !== 0) {
                const name = buffer.getUTF8();
                result.set(name, deserializeTag(kind, buffer, useMaps));
                kind = buffer.getByte();
            }
            if (useMaps) {
                return result;
            }
            else {
                return strMapToObj(result);
            }
        case tags_1.TagType.TAG_INT_ARRAY:
            const intLen = buffer.getInt();
            const intResult = tags_1.intArray([]);
            for (let _i = 0; _i < intLen; _i++) {
                intResult.push(deserializeTag(tags_1.TagType.TAG_INT, buffer, useMaps));
            }
            return intResult;
        case tags_1.TagType.TAG_LONG_ARRAY:
            const longLen = buffer.getInt();
            const longResult = tags_1.longArray([]);
            for (let _i = 0; _i < longLen; _i++) {
                longResult.push(deserializeTag(tags_1.TagType.TAG_LONG, buffer, useMaps));
            }
            return longResult;
        default:
            throw new RangeError(`Invalid tag type around index ${buffer.index}: ${type}`);
    }
}
function strMapToObj(strMap) {
    const obj = Object.create(null);
    for (const [k, v] of strMap) {
        obj[k] = v;
    }
    return obj;
}
